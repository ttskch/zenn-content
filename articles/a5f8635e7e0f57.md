---
title: "Symfony 6でアクセストークンによるユーザー認証を実装し、開発・テスト時にはアクセストークンなしで任意のユーザーをログインさせる方法"
emoji: "🔐"
type: "tech"
topics: ["php", "symfony"]
published: true
---

# やりたいこと

以下のようなユースケースを想定します。

* Symfony 6でSPAのバックエンドを実装する
* ユーザー認証にはIDaaSを使い、フロントエンドが直接IDaaSにログインしてアクセストークンを取得している
* Symfony側のユーザーエンティティにはIDaaS上のユーザーIDが保存されている

この場合に、フロントエンドからのリクエストヘッダーに乗っているアクセストークンをもとに、Symfony側で対応するユーザーをログイン状態にする方法を解説します。

また、このような構成においては、**開発時にまでいちいち本物のアクセストークンを乗せないとリクエストできないのでは不便すぎる** ので、開発環境・テスト環境においてのみ、**ユーザーIDなどを指定して任意のユーザーをログイン状態にすることができるようにしたい** です。その方法についても解説します。

# 1. アクセストークンによるユーザー認証

まず、アクセストークンによるユーザー認証についてです。

これについては、

[How to use Access Token Authentication (Symfony Docs)](https://symfony.com/doc/current/security/access_token.html)

こちらの公式ドキュメントで解説されている `AccessTokenHandler` を使えば一瞬で実装できてしまいます🙆‍♂️

> `AccessTokenHandler` は [Symfony 6.2で新たに導入された](https://symfony.com/blog/new-in-symfony-6-2-access-token-authenticator) 機能です。

具体的には、まず以下のようなクラスを実装します。

```php
<?php

declare(strict_types=1);

namespace App\Security;

use Symfony\Component\Security\Http\AccessToken\AccessTokenHandlerInterface;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;

class AccessTokenHandler implements AccessTokenHandlerInterface
{
    // `Auth` は IDaaS の SDK のイメージ
    public function __construct(private readonly Auth $auth)
    {
    }

    public function getUserBadgeFrom(string $accessToken): UserBadge
    {
        try {
            // 例えば IDaaS の SDK の login() というメソッドによって IDaaS のユーザー情報が取得できるイメージ
            $idaasUser = $this->auth->login($accessToken);

            return new UserBadge($idaasUser->id);
        } catch (IdaasAccessTokenExpiredException|IdaasAccessTokenInvalidException|IdaasAccessTokenRevokedException $e) {
            // 例えば IDaaS への認証失敗時に、失敗理由に応じて上記のような例外がスローされるイメージ
            
            throw new BadCredentialsException(previous: $e);
        }
    }
}
```

あとは、`security.yaml` でファイアウォールの `access_token.token_handler` に上記クラスを設定してあげるだけです。

```yaml
# config/packages/security.yaml

security:
  providers:
    app_user_provider:
      entity:
        # 例えば User エンティティに idaasId というプロパティがあるイメージ
        class: App\Entity\User
        property: idaasId

  firewalls:
    main:
      lazy: true
      stateless: true
      access_token:
        token_handler: App\Security\AccessTokenHandler
```

簡単ですね！🙌

Symfony 6.1以前では [Custom Authenticator](https://symfony.com/doc/current/security/custom_authenticator.html) を書いて対応していましたが、`AccessTokenHandler` はアクセストークンによる認証に特化することでいくらかコード量を減らせるようになっています。

# 2. 開発環境・テスト環境においてのみ任意のユーザーをログインさせられるように

次に、開発環境・テスト環境においてのみ任意のユーザーをログインさせられるようにする方法です。

方針として、

* 開発環境においては、`.env.local` で環境変数を設定することによって、常にそのユーザーでログインした状態になるようにしたい
* テスト環境においては、テスコード内から動的にログインさせるユーザーを指定できるようにしたい

という2点を満たす実装を目指します。

これを叶えるべく、まずは以下のようなデバッグ用の `AccessTokenHandler` を作ります。

```php
<?php

declare(strict_types=1);

namespace App\Dev\Security;

use Symfony\Component\Security\Http\AccessToken\AccessTokenHandlerInterface;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;

class DebugAccessTokenHandler implements AccessTokenHandlerInterface
{
    public function getUserBadgeFrom(string $accessToken): UserBadge
    {
        // アクセストークンとして渡された値をそのままキーにしてSymfonyユーザーを探す
        return new UserBadge($accessToken);
    }
}
```

この上で、**環境変数またはリクエストヘッダーで指定されたIDaaS上のユーザーIDを、アクセストークンとして `DebugAccessTokenHandler` に渡す** ための [Custom AccessTokenHandler](https://symfony.com/doc/current/security/access_token.html#2-configure-the-token-extractor-optional) を実装します。

```php
<?php

declare(strict_types=1);

namespace App\Dev\Security;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Security\Http\AccessToken\AccessTokenExtractorInterface;

class DebugAccessTokenExtractor implements AccessTokenExtractorInterface
{
    public function __construct(private readonly string $idaasId = '')
    {
    }

    public function extractAccessToken(Request $request): ?string
    {
        // コンストラクタで $idaasId がセットされている場合はその値を、セットされていない場合はリクエストヘッダーで指定された値を、アクセストークンとして返す
        return $this->idaasId ?: $request->headers->get('x-debug-auth-idaas-id');
    }
}
```

あとは `security.yaml` で、開発環境・テスト環境においてのみ、もとの `AccessTokenHandler` の代わりに上記の `DebugAccessTokenHander` および `DebugAccessTokenExtractor` を使用するように設定してあげればOKというわけです。

```yaml
# config/packages/security.yaml

security:
  # ...

when@dev:
  security:
    firewalls:
      main:
        access_token:
          token_handler: App\Dev\Security\DebugAccessTokenHandler
          token_extractors: App\Dev\Security\DebugAccessTokenExtractor

when@test:
  security:
    firewalls:
      main:
        access_token:
          token_handler: App\Dev\Security\DebugAccessTokenHandler
          token_extractors: App\Dev\Security\DebugAccessTokenExtractor
```

ところで、今回作成した `AccessTokenHandler` `AccessTokenExtractor` ですが、**万が一にも間違って本番環境上で実行されてしまうと、致命的なセキュリティリスクになってしまいます。**

なので、**本番環境ではこれらのクラスがインスタンス化自体されないようにしておく** のが賢明です。

実はそのために、上記の2クラスは名前空間が `App\Security` ではなく `App\Dev\Security` になっていました。

まず、これらのクラスは `src` 配下ではなく `src-dev` というディレクトリを作ってその配下に設置します。

* `src-dev/Security/DebugAccessTokenHandler.php`
* `src-dev/Security/DebugAccessTokenExtractor.php`

そして、`composer.json` の `autoload-dev` に以下のようにオートロードの設定を1行追記します。

```diff
      "autoload": {
          "psr-4": {
              "App\\": "src/"
          }
      },
      "autoload-dev": {
          "psr-4": {
+             "App\\Dev\\": "src-dev/",
              "App\\Tests\\": "tests/"
          }
      },
```

これで、`src-dev` 配下のクラス群は開発環境でしかオートロードされなくなります。

続いて、`services_dev.yaml` と `services_test.yaml` を作成し、以下のような内容とします。

```yaml
# config/services_dev.yaml

services:
  _defaults:
    autowire: true
    autoconfigure: true

  App\Dev\:
    resource: '../src-dev/'

  App\Dev\Security\DebugAccessTokenExtractor:
    arguments:
      $idaasId: '%env(DEBUG_AUTH_IDAAS_ID)%'
```

```yaml
# config/services_test.yaml

services:
  _defaults:
    autowire: true
    autoconfigure: true
    public: true

  App\Dev\:
    resource: '../src-dev/'
```

これで、

* 開発環境・テスト環境においてのみ、`src-dev` 配下のクラス群がオートワイヤリングによって自動でサービスコンテナに登録される
* 開発環境においてのみ、`DebugAccessTokenExtractor` のコンストラクタ引数に `DEBUG_AUTH_IDAASID` 環境変数の値が渡される
* （テスト環境においてのみ、すべてのサービスがデフォルトで `public`（`$container->get(サービスID)` でインスタンスを取得できる）となる）

という設定ができました。

これにより、`.env.local` に `DEBUG_AUTH_IDAASID={DB上の任意のユーザーのidaasIdカラムの値}` を書いておけば、開発環境においては常にそのユーザーでログインした状態で動作させることができます。

> `.env` のほうには雛形として `DEBUG_AUTH_IDAASID=` とだけ書いておく必要があります。`.env` にも `.env.local` にも `DEBUG_AUTH_IDAASID` 環境変数自体が存在しない状態だと、`services_dev.yaml` の `App\Dev\Security\DebugAccessTokenExtractor` サービスの構築がエラーになってしまうためです。
>
> `.env` にだけ `DEBUG_AUTH_IDAASID=` が書かれていて `.env.local` には何も書かれていない、という状態であれば、`DebugAccessTokenExtractor` クラスの `$idaasId` プロパティの値が `''` になり、`extractAccessToken()` メソッドの戻り値が `null` になるので、正常に認証エラーになります。

また、テスト環境においては、リクエストの `x-debug-auth-idaas-id` ヘッダーにDB上の任意のユーザーの `idaasId` カラムの値を乗せれば、リクエストごとに任意のユーザーでログインさせることができます。

これで開発・テストがしやすくなりましたね！🙌
