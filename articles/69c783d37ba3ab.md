---
title: "Symfony UX Autocompleteで、選択肢にない値を手入力もできる選択式のフォーム項目の作り方"
emoji: "🎻"
type: "tech"
topics: ["php", "symfony", "form", "tomselect"]
published: true
---

# やりたいこと

「選択肢から選ぶこともできるし、選択肢にない値を手入力もできる」ようなフォーム項目は、単一入力ならHTMLの [datalist](https://developer.mozilla.org/ja/docs/Web/HTML/Element/datalist) を使えばよいと思うのですが、datalistを使いつつ複数入力できるものを作るとなると、（Symfony Formなら [CollectionType](https://symfony.com/doc/current/reference/forms/types/collection.html) を使って）入力欄自体を増やせるようにする必要があり、あまりUXがよくありません。

そこで、[Symfony UX Autocomplete](https://symfony.com/bundles/ux-autocomplete/current/index.html) を使って、下図のような「選択または入力」ができるフォーム項目を作ります🙆‍♂️

![](https://img.esa.io/uploads/production/attachments/15064/2024/10/04/77821/1afec829-b968-44ed-aa1f-e50adf8f37e4.gif)

# 概要

Symfony UX Autocompleteは、とりあえずSymfonyアプリにインストールしておけば **`<select>` タグを全部いい感じにしてくれる最高のやつ** です。

フロントエンドの実装には [Tom Select](https://tom-select.js.org/) というライブラリが使われており、[Tom Selectが備えている機能](https://tom-select.js.org/examples/create-filter/) を用いて、選択肢にない値を手入力もできる選択式のフォーム項目を作ることができます。

ただし、フロントエンド側のTom Selectの状態とバックエンド側のSymfony Formの状態を適切に連携させるには多少やることがあります。この記事ではその辺りも含めて順を追ってやり方を説明していきます。

> Symfony UX Autocompleteについては過去に以下のような記事も書いているのでよかったら覗いてみてください🤲
> 
> https://zenn.dev/ttskch/articles/dc3c09b71f73d4

# 1. FormTypeを作る

まずはFormTypeを作ります。

```php
<?php

declare(strict_types=1);

namespace App\Form;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
use Symfony\Component\OptionsResolver\OptionsResolver;

class CreatableChoiceType extends AbstractType
{
    public function configureOptions(OptionsResolver $resolver): void
    {
        $resolver->setDefaults([
            'attr' => [
                'data-placeholder' => '選択または入力してください',
            ],
            'autocomplete' => true,
            'tom_select_options' => [
                'create' => true,
                'createOnBlur' => true,
                'persist' => false,
            ],
        ]);
    }

    public function getParent(): string
    {
        return ChoiceType::class;
    }
}
```

`'autocomplete' => true` でSymfony UX Autocompleteを有効にし、[`tom_select_options`](https://symfony.com/bundles/ux-autocomplete/current/index.html#form-options-reference) で [Tom Selectの初期化オプション](https://tom-select.js.org/docs/) を任意に渡しています。

* `'create' => true` が、選択肢にない値を手入力できるようにする設定
* `'createOnBlur' => true` は、手入力中にフォーム項目からフォーカスを外したときに、入力をキャンセルするのではなく入力を完了させる設定
* `persist => false` は、手入力した値を選択解除したときに選択肢に残さないための設定

です。

利用側では以下のような感じで使えます。

```php
$builder
    ->add('foos', CreatableChoiceType::class, [
        'choices' => array_combine($values = ['選択肢1', '選択肢2', '選択肢3'], $values),
        'multiple' => true,
    ])
;
```

これで、「選択または入力」ができるフォーム項目を画面に出力することができます🙆‍♂️

# 2. 手入力された値がエラーにならずバックエンドに渡ってくるようにする

実は現状だと手入力した値（つまり選択肢にない値）が含まれる状態でフォームを送信すると、バックエンド側で「選択した値は無効です。」のエラーになってします。

これを解消するため、CreatableChoiceTypeに以下のコードを追記します。

```diff
  <?php
  
  declare(strict_types=1);
  
  namespace App\Form;
  
  use Symfony\Component\Form\AbstractType;
  use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
+ use Symfony\Component\Form\FormBuilderInterface;
+ use Symfony\Component\Form\FormEvent;
+ use Symfony\Component\Form\FormEvents;
  use Symfony\Component\OptionsResolver\OptionsResolver;
  
  class CreatableChoiceType extends AbstractType
  {
+     public function buildForm(FormBuilderInterface $builder, array $options): void
+     {
+         parent::buildForm($builder, $options);
+ 
+         $builder->addEventListener(FormEvents::PRE_SUBMIT, fn (FormEvent $event) => $event->stopPropagation(), 1); // ①
+         $builder->addEventListener(FormEvents::POST_SUBMIT, fn (FormEvent $event) => $event->stopPropagation(), 1); // ②
+         $builder->resetViewTransformers(); // ③
+     }
+ 
      public function configureOptions(OptionsResolver $resolver): void
      {
          $resolver->setDefaults([
              'attr' => [
                  'data-placeholder' => '選択または入力してください',
                  'data-controller' => 'autocomplete',
              ],
              'autocomplete' => true,
              'tom_select_options' => [
                  'create' => true,
                  'createOnBlur' => true,
                  'persist' => false,
              ],
          ]);
      }
  
      public function getParent(): string
      {
          return ChoiceType::class;
      }
  }
```

①は、ChoiceTypeの [このイベントリスナー](https://github.com/symfony/form/blob/v7.1.5/Extension/Core/Type/ChoiceType.php#L101-L165) を無効化するためのコードです。このイベントリスナーは、選択肢にない値をフォームの送信データから削除する処理を行っています。今回は選択肢にない値も正常な値として受け取りたいので、イベントリスナー自体を無効にしてしまって構いません。

より優先度の高い（第3引数の `1`）イベントリスナーを登録し、その中で `stopPropagation()` することで次以降のイベントハンドラーの処理を無効化しています。CreatableChoiceTypeを継承したFormTypeで有効なイベントリスナーを登録したい場合には優先度を `2` 以上にする必要があるので、その点は要注意です。

②は、ChoiceTypeの [このイベントリスナー](https://github.com/symfony/form/blob/v7.1.5/Extension/Core/Type/ChoiceType.php#L172-L187) を無効化するためのコードです。このイベントリスナーは、選択肢にない値に対してフォームのエラーを出力する処理を行っています。これも今回はイベントリスナー自体を無効にしてしまって構いません。

③は、ChoiceTypeの [この処理](https://github.com/symfony/form/blob/v7.1.5/Extension/Core/Type/ChoiceType.php#L189-L193) を無効化するためのコードです。フォームの入力値をSymfony Formの内部表現に変換するためのViewTransformerを登録する処理ですが、このViewTransformerが実行されると選択肢にない値に対してエラーが発せられてしまうので、`resetViewTransformers()` でViewTransformerの登録を無かったことにしています。

これで、手入力した値もエラーになったり削除されたりせずバックエンドに渡ってくるようになりました🙆‍♂️

# 3. 手入力された値がセットされているフォームを描画したときにTom Select上でその値が選択状態になるようにする

これが最後のステップです。

現状だと、値がセットされているフォームを画面に描画した場合（例えば、検索フォームで検索条件が入力値に反映された状態で描画する場合や、フォームにエラーがあったために入力値を残したままエラーを伴って描画する場合など）に、実際にセットされている値のうち、選択肢にあるものだけが選択状態となり、手入力された値は選択されていないような表示になってしまいます。

これは、CreatableChoiceTypeを描画する際に、`choices` にあるものだけが `<option>` タグとして出力されるため、Tom Selectが `<select>` タグをもとに初期化処理を行う時点ですでに「選択肢以外にどんな値が手入力されていたのか」という情報が消失してしまっているためです。

なので、対処方法としては、data属性などに実際の値のリストを持たせた状態で `<select>` タグを出力し、Tom Selectの初期化処理においてそのdata属性から取得した値リストを選択状態にするような処理を自前でカスタマイズして書く、ということが必要になります。

まずはCreatableChoiceTypeに以下のコードを追記し、フォームにセットされている値のリストを `data-data` というdata属性に持たせておくようにします。

```diff
  <?php
  
  declare(strict_types=1);
  
  namespace App\Form;
  
  use Symfony\Component\Form\AbstractType;
  use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
  use Symfony\Component\Form\FormBuilderInterface;
  use Symfony\Component\Form\FormEvent;
  use Symfony\Component\Form\FormEvents;
+ use Symfony\Component\Form\FormInterface;
+ use Symfony\Component\Form\FormView;
  use Symfony\Component\OptionsResolver\OptionsResolver;
  
  class CreatableChoiceType extends AbstractType
  {
      public function buildForm(FormBuilderInterface $builder, array $options): void
      {
          parent::buildForm($builder, $options);
  
          $builder->addEventListener(FormEvents::PRE_SUBMIT, fn (FormEvent $event) => $event->stopPropagation(), 1);
          $builder->addEventListener(FormEvents::POST_SUBMIT, fn (FormEvent $event) => $event->stopPropagation(), 1);
          $builder->resetViewTransformers();
      }
  
+     public function buildView(FormView $view, FormInterface $form, array $options): void
+     {
+         parent::buildView($view, $form, $options);
+ 
+         $data = json_encode($view->vars['data'], JSON_UNESCAPED_UNICODE | JSON_THROW_ON_ERROR);
+         $view->vars['attr']['data-data'] = $data;
+     }
+ 
      public function configureOptions(OptionsResolver $resolver): void
      {
          $resolver->setDefaults([
              'attr' => [
                  'data-placeholder' => '選択または入力してください',
                  'data-controller' => 'autocomplete',
              ],
              'autocomplete' => true,
              'tom_select_options' => [
                  'create' => true,
                  'createOnBlur' => true,
                  'persist' => false,
              ],
          ]);
      }
  
      public function getParent(): string
      {
          return ChoiceType::class;
      }
  }
```

その上で、[Symfony UX Autocompleteの公式ドキュメントのここ](https://symfony.com/bundles/ux-autocomplete/current/index.html#extending-tom-select) などを参考にStimulusのコントローラーを以下のような内容で書きます。

```js
// assets/controllers/custom-autocomplete_controller.js
import { Controller } from '@hotwired/stimulus'

export default class extends Controller {
  initialize() {
    this._onPreConnect = this._onPreConnect.bind(this)
    this._onConnect = this._onConnect.bind(this)
  }

  connect() {
    this.element.addEventListener('autocomplete:pre-connect', this._onPreConnect)
    this.element.addEventListener('autocomplete:connect', this._onConnect)
  }

  disconnect() {
    this.element.removeEventListener('autocomplete:pre-connect', this._onConnect)
    this.element.removeEventListener('autocomplete:connect', this._onPreConnect)
  }

  _onPreConnect(event) {
  }

  _onConnect(event) {
    const options = event.detail.options
    const tomSelect = event.detail.tomSelect
    
    // 選択肢の追加が可能な項目において、リスト外の値も含めたすべての値を初期値に反映する
    if (options.create) { // ①
      tomSelect.clearActiveItems() // ②
      JSON.parse(tomSelect.input.dataset.data).forEach((value) => { // ③
        tomSelect.addOption({value, text: value}, true) // ④
        tomSelect.addItem(value, true) // ⑤
      })
    }
  }
}
```

①は、Tom Selectの `create` オプションが有効な項目のみを対象とするためのif文です。

②で一旦すべての選択を解除したあと、③で `data-data` 属性から取得した値リストに対するイテレートを開始し、イテレート内では、④で（選択肢自体がない場合＝手入力された値の場合は）選択肢自体を追加し、⑤でそれを選択状態にしています。

あとはこのStimulusコントローラーをCreatableChoiceTypeに割り当てればOKです。

```diff
  <?php
  
  declare(strict_types=1);
  
  namespace App\Form;
  
  use Symfony\Component\Form\AbstractType;
  use Symfony\Component\Form\Extension\Core\Type\ChoiceType;
  use Symfony\Component\Form\FormBuilderInterface;
  use Symfony\Component\Form\FormEvent;
  use Symfony\Component\Form\FormEvents;
  use Symfony\Component\Form\FormInterface;
  use Symfony\Component\Form\FormView;
  use Symfony\Component\OptionsResolver\OptionsResolver;
  
  class CreatableChoiceType extends AbstractType
  {
      public function buildForm(FormBuilderInterface $builder, array $options): void
      {
          parent::buildForm($builder, $options);
  
          $builder->addEventListener(FormEvents::PRE_SUBMIT, fn (FormEvent $event) => $event->stopPropagation(), 1);
          $builder->addEventListener(FormEvents::POST_SUBMIT, fn (FormEvent $event) => $event->stopPropagation(), 1);
          $builder->resetViewTransformers();
      }
  
      public function buildView(FormView $view, FormInterface $form, array $options): void
      {
          parent::buildView($view, $form, $options);
  
          $data = json_encode($view->vars['data'], JSON_UNESCAPED_UNICODE | JSON_THROW_ON_ERROR);
          $view->vars['attr']['data-data'] = $data;
      }
  
      public function configureOptions(OptionsResolver $resolver): void
      {
          $resolver->setDefaults([
              'attr' => [
                  'data-placeholder' => '選択または入力してください',
+                 'data-controller' => 'custom-autocomplete',
              ],
              'autocomplete' => true,
              'tom_select_options' => [
                  'create' => true,
                  'createOnBlur' => true,
                  'persist' => false,
              ],
          ]);
      }
  
      public function getParent(): string
      {
          return ChoiceType::class;
      }
  }
```

これで、手入力された値がセットされているフォームであっても、描画時にすべての値が選択状態になってくれるようになりました🙆‍♂️

以上で完成です🎉

> 最初に貼った動画はStimulusコントローラーをもう少しいじっていて、Tom Selectの色々なワーディングを日本語にしたりしていますが、その辺りの細かいやり方はまた別の機会に記事にするかもしれません🙏

# ちなみに

https://tom-select.js.org/examples/ の1つ目の例のように、

```html
<input value="選択肢1,選択肢2,選択肢3">
```

のような `value` に値をカンマ区切りで繋いだ文字列が入っている `<input>` タグもTom Select化することができますが、Symfony FormでこれをやるとTom Select上の選択状態にかかわらず、フォーム送信時には結局すべての値がバックエンドに送信されてしまうため、そのままでは今回の用途には使えません。
